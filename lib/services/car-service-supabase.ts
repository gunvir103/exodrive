import { handleSupabaseError } from "@/lib/supabase/client"
// No longer needed as we'll use the browser client in the form
// import { createSupabaseServerClient, createSupabaseServiceRoleClient } from "@/lib/supabase/server"
// import { cookies } from 'next/headers' // Not directly used in service logic now
import { BUCKET_NAMES } from "@/lib/supabase/storage-service"
import type { SupabaseClient } from '@supabase/supabase-js'
import type { Database } from '@/lib/types/database.types' // Import generated types

// Type definitions based on the actual schema from list_tables
// Assuming standard foreign key 'car_id' and primary key 'id' (uuid)

// Base Car Type (from 'cars' table)
export type CarBase = Omit<Database['public']['Tables']['cars']['Row'], 'created_at' | 'updated_at'> & {
    createdAt?: string | null; // Keep original strings for now, convert later if needed
    updatedAt?: string | null;
};

// Related Data Types
export type CarPricing = Database['public']['Tables']['car_pricing']['Row'];
export type CarImage = Database['public']['Tables']['car_images']['Row'];
export type CarFeature = Database['public']['Tables']['car_features']['Row'];
export type CarSpecification = Database['public']['Tables']['car_specifications']['Row'];

// Composite Application Car Type
// Combines base car with related data
export type AppCar = CarBase & {
    pricing: CarPricing | null; // Assuming one-to-one pricing for simplicity, adjust if needed
    images: CarImage[];
    features: CarFeature[];
    specifications: CarSpecification[];
};

// Type for creating/updating (omit IDs generated by DB)
export type CarInsertData = Omit<Database['public']['Tables']['cars']['Insert'], 'id' | 'created_at' | 'updated_at'>;
export type PricingInsertData = Omit<Database['public']['Tables']['car_pricing']['Insert'], 'id' | 'car_id' | 'created_at' | 'updated_at'>;
export type ImageInsertData = Omit<Database['public']['Tables']['car_images']['Insert'], 'id' | 'car_id' | 'created_at'>;
export type FeatureInsertData = Omit<Database['public']['Tables']['car_features']['Insert'], 'id' | 'car_id' | 'created_at'>;
export type SpecificationInsertData = Omit<Database['public']['Tables']['car_specifications']['Insert'], 'id' | 'car_id' | 'created_at'>;

// Composite type for form submission / service input
// Remove fields not in cars.Insert/Update: make, model, year, engine, transmission, drivetrain
export type AppCarUpsert = {
    name: string; // Required for slug generation
    // make?: string | null; // Belongs in specs?
    // model?: string | null; // Belongs in specs?
    // year?: number | null; // Belongs in specs?
    category: string;
    description?: string | null; // Nullable string allowed
    short_description?: string | null; // Nullable string allowed
    // engine?: string | null; // Belongs in specs?
    // transmission?: string | null; // Belongs in specs?
    // drivetrain?: string | null; // Belongs in specs?
    available?: boolean | null; // Nullable boolean allowed
    featured?: boolean | null; // Nullable boolean allowed
    hidden?: boolean | null; // Nullable boolean allowed
    // Related data
    pricing: PricingInsertData;
    images: ImageInsertData[];
    features: FeatureInsertData[];
    specifications: SpecificationInsertData[];
};

// Define type for the optimized list item structure
export type OptimizedCarListItem = {
  id: string;
  slug: string;
  name: string;
  category: string | null; 
  available: boolean | null;
  featured: boolean | null;
  hidden: boolean | null;
  created_at: string | null;
  primary_image_url?: string | null; // Make optional
  price_per_day?: number | null;   // Make optional
  shortDescription?: string | null; // Make optional
};

// --- Helper Functions (Transformation logic removed as we use related tables directly) ---
// No longer needed as we fetch joined data or assemble it


// --- Service Object ---
export const carServiceSupabase = {
    /**
     * Get *base* car data by ID (Internal helper or basic fetch)
     * Fetches only from the 'cars' table.
     */
    _getBaseCarById: async (supabase: SupabaseClient, id: string): Promise<CarBase | null> => {
        try {
            const { data, error } = await supabase
                .from("cars")
                .select("*")
                .eq("id", id)
                .maybeSingle<CarBase>();

            if (error) throw error;
            return data;
        } catch (error) {
            if (error instanceof Error) {
                throw new Error(handleSupabaseError(error));
            }
            throw new Error("An unexpected error occurred fetching base car by ID");
        }
    },

    /**
     * Get *base* car data by Slug (Internal helper or basic fetch)
     * Fetches only from the 'cars' table.
     */
     _getBaseCarBySlug: async (supabase: SupabaseClient, slug: string): Promise<CarBase | null> => {
        try {
            const { data, error } = await supabase
                .from("cars")
                .select("*")
                .eq("slug", slug)
                .maybeSingle<CarBase>();

            if (error) throw error;
            return data;
        } catch (error) {
            if (error instanceof Error) {
                throw new Error(handleSupabaseError(error));
            }
            throw new Error("An unexpected error occurred fetching base car by slug");
        }
    },


    /**
     * Get a complete car with all related data by ID (Used by Edit Page, etc.)
     */
    getCarById: async (supabase: SupabaseClient, id: string): Promise<AppCar | null> => {
        try {
            // Fetch base car data
            const { data: carData, error: carError } = await supabase
                .from("cars")
                .select(`
                    *,
                    pricing:car_pricing(*),
                    images:car_images(*),
                    features:car_features(*),
                    specifications:car_specifications(*)
                `)
                .eq("id", id)
                .maybeSingle(); // Use maybeSingle to handle null case gracefully


            if (carError) throw carError;
            if (!carData) return null;

            // Type the nested select result
            interface CarWithRelations extends CarBase {
                pricing: CarPricing[] | CarPricing | null;
                images: CarImage[] | null;
                features: CarFeature[] | null;
                specifications: CarSpecification[] | null;
            }
            const typedCarData = carData as CarWithRelations;

            // Assemble the AppCar object
            const assembledCar: AppCar = {
                ...typedCarData, // Spread base car fields
                pricing: Array.isArray(typedCarData.pricing) ? typedCarData.pricing[0] || null : typedCarData.pricing || null, // Handle potential array/single object
                images: typedCarData.images || [],
                features: typedCarData.features || [],
                specifications: typedCarData.specifications || [],
                // Ensure boolean fields have defaults if null
                available: typedCarData.available ?? true,
                featured: typedCarData.featured ?? false,
                hidden: typedCarData.hidden ?? false,
            };

             // Sort images by sort_order if the field exists
             if (assembledCar.images.length > 0 && 'sort_order' in assembledCar.images[0]) {
                assembledCar.images.sort((a, b) => (a.sort_order ?? 0) - (b.sort_order ?? 0));
             }


            return assembledCar;
        } catch (error) {
            console.error("Error in getCarById:", error);
            if (error instanceof Error) {
                throw new Error(handleSupabaseError(error));
            }
            throw new Error("An unexpected error occurred fetching car by ID");
        }
    },


    /**
     * Get a complete car with all related data by Slug (Used by Public Fleet Page)
     */
    getCarBySlug: async (supabase: SupabaseClient, slug: string): Promise<AppCar | null> => {
        try {
            // Fetch base car data and related data using joins/selects
             const { data: carData, error: carError } = await supabase
                .from("cars")
                .select(`
                    *,
                    pricing:car_pricing(*),
                    images:car_images(*),
                    features:car_features(*),
                    specifications:car_specifications(*)
                `)
                .eq("slug", slug)
                .maybeSingle(); // Use maybeSingle


            if (carError) throw carError;
            if (!carData) return null;

            // Assemble the AppCar object (similar to getCarById)
             interface CarWithRelations extends CarBase {
                pricing: CarPricing[] | CarPricing | null;
                images: CarImage[] | null;
                features: CarFeature[] | null;
                specifications: CarSpecification[] | null;
             }
             const typedCarData = carData as CarWithRelations;
             const assembledCar: AppCar = {
                ...typedCarData,
                pricing: Array.isArray(typedCarData.pricing) ? typedCarData.pricing[0] || null : typedCarData.pricing || null,
                images: typedCarData.images || [],
                features: typedCarData.features || [],
                specifications: typedCarData.specifications || [],
                available: typedCarData.available ?? true,
                featured: typedCarData.featured ?? false,
                hidden: typedCarData.hidden ?? false,
            };

             // Sort images by sort_order
             if (assembledCar.images.length > 0 && 'sort_order' in assembledCar.images[0]) {
                assembledCar.images.sort((a, b) => (a.sort_order ?? 0) - (b.sort_order ?? 0));
             }

            return assembledCar;
        } catch (error) {
            console.error("Error in getCarBySlug:", error);
            if (error instanceof Error) {
                throw new Error(handleSupabaseError(error));
            }
            throw new Error("An unexpected error occurred fetching car by slug");
        }
    },

    /**
     * Get base details for all cars (for Admin List)
     * Includes minimal related data (e.g., primary image URL, price)
     */
    getAllCarsForAdminList: async (supabase: SupabaseClient): Promise<OptimizedCarListItem[]> => {
      console.log("Call to getAllCarsForAdminList");
      try {
        const { data, error } = await supabase
            .from("cars")
            .select(` id, slug, name, category, available, featured, hidden, created_at, pricing:car_pricing(base_price), images:car_images(url, is_primary, sort_order) `)
            // No filtering by hidden status - we want ALL cars
            .order("created_at", { ascending: false });

        if (error) {
          console.error("Error in getAllCarsForAdminList Query:", error);
          throw error;
        }
        if (!data) return [];

        // Log raw data to see if hidden cars are included
        console.log(`getAllCarsForAdminList raw DB results: ${data.length} cars total`);
        const hiddenCars = data.filter(car => car.hidden === true);
        console.log(`Hidden cars in DB results: ${hiddenCars.length}`);
        hiddenCars.forEach(car => console.log(`DB hidden car: ${car.name}, ${car.id}, hidden=${car.hidden}`));

        interface CarListQueryResult {
            id: string;
            slug: string;
            name: string;
            category: string | null;
            available: boolean | null;
            featured: boolean | null;
            hidden: boolean | null;
            created_at: string | null;
            pricing: { base_price: number }[] | { base_price: number } | null;
            images: { url: string; is_primary: boolean; sort_order: number }[] | null;
        }
        
        return data.map((car: CarListQueryResult): OptimizedCarListItem => {
            let primaryImage = null;
            try {
                primaryImage = car.images?.sort((a,b) => (a.sort_order ?? 0) - (b.sort_order ?? 0)).find((img) => img.is_primary) || car.images?.[0];
            } catch (e) { console.error(`Error processing images for car ID ${car?.id}:`, e); }

            let price = null;
            try {
                if(Array.isArray(car.pricing)) { price = car.pricing?.[0]?.base_price; }
                else if (typeof car.pricing === 'object' && car.pricing !== null) { price = car.pricing?.base_price; }
            } catch (e) { console.error(`Error processing pricing for car ID ${car?.id}:`, e); }
            
            // Return only the explicitly defined fields for OptimizedCarListItem
            const listItem: OptimizedCarListItem = {
              id: car.id,
              slug: car.slug,
              name: car.name,
              category: car.category,
              available: car.available,
              featured: car.featured,
              hidden: car.hidden,
              created_at: car.created_at,
              primary_image_url: primaryImage?.url ?? null, // Ensure null if undefined
              price_per_day: price ?? null, // Ensure null if undefined
              // shortDescription is not part of this list type's definition
           };
           return listItem;
        });
      } catch (error) {
        console.error("Error in getAllCarsForAdminList processing:", error);
        if (error instanceof Error) throw new Error(handleSupabaseError(error));
        throw new Error("An unexpected error occurred fetching cars for admin list");
      }
    },


    /**
     * Get visible cars for the public fleet (Optimized fetch)
     * Includes necessary data for display (name, slug, price, primary image, category)
     */
    getVisibleCarsForFleet: async (supabase: SupabaseClient): Promise<OptimizedCarListItem[]> => {
        try {
            const { data, error } = await supabase
                .from("cars")
                .select(` id, slug, name, category, short_description, featured, pricing:car_pricing(base_price), images:car_images(url, is_primary, sort_order) `)
                .eq("available", true)
                .eq("hidden", false)
                .order("featured", { ascending: false })
                .order("created_at", { ascending: false });

            if (error) { console.error("Error in getVisibleCarsForFleet Query:", error); throw error; }
            if (!data) return [];

            interface CarFleetQueryResult {
                id: string;
                slug: string;
                name: string;
                category: string | null;
                short_description: string | null;
                featured: boolean | null;
                pricing: { base_price: number }[] | { base_price: number } | null;
                images: { url: string; is_primary: boolean; sort_order: number }[] | null;
            }
            
            return data.map((car: CarFleetQueryResult): OptimizedCarListItem => {
                let primaryImage = null;
                try { primaryImage = car.images?.sort((a,b) => (a.sort_order ?? 0) - (b.sort_order ?? 0)).find((img) => img.is_primary) || car.images?.[0]; } catch(e) {console.error("ImgErr", e)}
                let price = null;
                try {
                    if(Array.isArray(car.pricing)) { price = car.pricing?.[0]?.base_price; }
                    else if (typeof car.pricing === 'object' && car.pricing !== null) { price = car.pricing?.base_price; }
                } catch (e) { console.error("PriceErr", e) }

                return {
                   id: car.id,
                   slug: car.slug,
                   name: car.name,
                   category: car.category,
                   shortDescription: car.short_description,
                   available: true,
                   featured: car.featured,
                   hidden: false, 
                   created_at: null, // Not selected
                   primary_image_url: primaryImage?.url, 
                   price_per_day: price 
                };
            });
        } catch (error) {
             console.error("Error in getVisibleCarsForFleet processing:", error);
             if (error instanceof Error) throw new Error(handleSupabaseError(error));
             throw new Error("An unexpected error occurred fetching visible cars for fleet");
        }
    },

     /**
     * Create a new car with related data using RPC for atomicity.
     */
    createCar: async (
        supabase: SupabaseClient,
        carData: AppCarUpsert
    ): Promise<AppCar> => {
        const rpcParams = {
            p_name: carData.name,
            p_category: carData.category,
            p_description: carData.description,
            p_short_description: carData.short_description,
            p_available: carData.available ?? true,
            p_featured: carData.featured ?? false,
            p_hidden: carData.hidden ?? false,
            p_created_by: null, // Pass null for placeholder
            p_pricing: carData.pricing,
            p_images: carData.images,
            p_features: carData.features,
            p_specifications: carData.specifications
        };
        console.log("Calling create_car_atomic with params:", JSON.stringify(rpcParams, null, 2));
        try {
            const { data: newCarId, error } = await supabase.rpc('create_car_atomic', rpcParams);
            if (error) { console.error("Error calling create_car_atomic RPC:", error); throw error; }
            if (!newCarId) { throw new Error("create_car_atomic RPC did not return a car ID."); }
            const newCar = await carServiceSupabase.getCarById(supabase, newCarId as string);
            if (!newCar) { throw new Error(`Failed fetch after create`); }
            return newCar;
        } catch (error) {
            // Handle potential errors during RPC call or subsequent fetch
             if (error instanceof Error) {
                 console.error("Caught error during createCar process:", error);
                 throw new Error(handleSupabaseError(error));
             }
             console.error("Caught unexpected error type during createCar:", error);
             throw new Error("An unexpected error occurred creating the car via RPC.");
        }
    },

     /**
     * Update a car and its related data using RPC for atomicity.
     * Handles deleting orphaned images from storage separately.
     */
    updateCar: async (
        supabase: SupabaseClient,
        carId: string,
        updates: Partial<AppCarUpsert> // Accept partial updates, but RPC needs full related state
    ): Promise<AppCar> => {
        let existingImagePaths: string[] = [];
        try {
            const { data: images, error: imgError } = await supabase.from("car_images").select("path").eq("car_id", carId);
            if (imgError) throw new Error(`Failed to fetch existing image paths: ${imgError.message}`);
            existingImagePaths = images?.map(img => img.path).filter(Boolean) as string[] || [];
        } catch (error) {
            console.error("Error fetching existing image paths before update:", error);
            if (error instanceof Error) throw error; 
            throw new Error("Could not verify existing images before update.");
        }

        const rpcParams = {
            p_car_id: carId,
            p_name: updates.name === undefined ? null : updates.name,
            p_category: updates.category === undefined ? null : updates.category,
            p_description: updates.description === undefined ? null : updates.description,
            p_short_description: updates.short_description === undefined ? null : updates.short_description,
            p_available: updates.available === undefined ? null : updates.available,
            p_featured: updates.featured === undefined ? null : updates.featured,
            p_hidden: updates.hidden === undefined ? null : updates.hidden,
            p_pricing: updates.pricing ?? null,
            p_images: updates.images ?? null,
            p_features: updates.features ?? null,
            p_specifications: updates.specifications ?? null
        };
        console.log("Calling update_car_atomic with params:", JSON.stringify(rpcParams, null, 2));
        try {
            const { error: rpcError } = await supabase.rpc('update_car_atomic', rpcParams);
            if (rpcError) throw rpcError; 

            // Storage Deletion AFTER DB success
            try {
                const updatedImagePaths = new Set(updates.images?.map(img => img.path).filter(Boolean) as string[] || []);
                const pathsToDelete = existingImagePaths.filter(path => path && !updatedImagePaths.has(path));
                if (pathsToDelete.length > 0) {
                    console.log("(Post-Update) Deleting orphaned images:", pathsToDelete);
                    const { error: storageError } = await supabase.storage.from(BUCKET_NAMES.VEHICLE_IMAGES).remove(pathsToDelete);
                    if (storageError) console.error("Failed storage delete:", storageError);
                }
            } catch (storageCatchError) { console.error("Storage cleanup error:", storageCatchError); }
            // --- END Storage Deletion ---

            const updatedCar = await carServiceSupabase.getCarById(supabase, carId);
            if (!updatedCar) throw new Error(`Failed fetch after update`);
            return updatedCar;
        } catch (error) {
            if (error instanceof Error) {
                console.error("Caught error during updateCar process:", error);
                throw new Error(handleSupabaseError(error));
            }
            console.error("Caught unexpected error type during updateCar:", error);
            throw new Error("An unexpected error occurred updating the car via RPC.");
        }
    },

    /**
     * Delete a car and its related data using RPC.
     * Handles deleting associated images from storage AFTERWARDS.
     */
    deleteCar: async (supabase: SupabaseClient, carId: string): Promise<boolean> => {
        let imagePathsToDelete: string[] = [];
        try {
            const { data: images, error: imgError } = await supabase.from("car_images").select("path").eq("car_id", carId);
            if (imgError) { console.error("Failed fetch img paths for delete:", imgError); }
            else { imagePathsToDelete = images?.map(img => img.path).filter(Boolean) as string[] || []; }

            const rpcParams = { p_car_id: carId };
            console.log("Calling delete_car_atomic:", rpcParams);
            const { error: rpcError } = await supabase.rpc('delete_car_atomic', rpcParams);
            if (rpcError) throw rpcError;

            // Storage Deletion AFTER DB success
            try {
                if (imagePathsToDelete.length > 0) {
                    console.log("(Post-Delete) Deleting images:", imagePathsToDelete);
                    const { error: storageError } = await supabase.storage.from(BUCKET_NAMES.VEHICLE_IMAGES).remove(imagePathsToDelete);
                    if (storageError) console.error("Storage delete failed:", storageError);
                }
            } catch (storageCatchError) { console.error("Storage cleanup error:", storageCatchError); }
            // --- END Storage Deletion ---

            return true; // DB delete succeeded
        } catch (error) {
            console.error(`Error deleting car ${carId}:`, error);
            if (error instanceof Error) {
                throw new Error(handleSupabaseError(error));
            }
            throw new Error("An unexpected error occurred deleting car via RPC");
        }
        return false; // Return false if any error occurred before returning true
    },

    /**
      * Get unique categories for filtering (from visible cars)
      */
     getCategories: async (supabase: SupabaseClient): Promise<string[]> => {
         try {
             // Fetch distinct categories from visible cars
             // Using an RPC function might be more efficient if the table is large.
             const { data, error } = await supabase
                 .from("cars")
                 .select("category")
                 .eq("available", true)
                 .eq("hidden", false);

             if (error) throw error;
             if (!data) return [];

             const categories = data.map((item) => item.category as string);
             // Filter out null/empty, get unique, sort
             return Array.from(new Set(categories.filter(Boolean))).sort();
         } catch (error) {
             console.error("Error fetching categories:", error);
             if (error instanceof Error) {
                 throw new Error(handleSupabaseError(error));
             }
             throw new Error("An unexpected error occurred fetching categories");
         }
     },

     /**
      * Get related cars by category (for car detail page)
      */
     getRelatedCars: async (supabase: SupabaseClient, carId: string, limit = 3): Promise<OptimizedCarListItem[]> => {
        try {
            const { data: currentCar, error: carError } = await supabase.from("cars").select("category").eq("id", carId).maybeSingle();
            if (carError) { console.error("Error fetching current car category:", carError); throw carError; }
            if (!currentCar?.category) return [];

            const { data: relatedCars, error: relatedError } = await supabase
                .from("cars")
                .select(` id, slug, name, category, pricing:car_pricing(base_price), images:car_images(url, is_primary, sort_order) `)
                .eq("category", currentCar.category).neq("id", carId).eq("available", true).eq("hidden", false).limit(limit);

            if (relatedError) { console.error("Error fetching related cars:", relatedError); throw relatedError; }
            if (!relatedCars) return [];

            interface RelatedCarQueryResult {
                id: string;
                slug: string;
                name: string;
                category: string | null;
                pricing: { base_price: number }[] | { base_price: number } | null;
                images: { url: string; is_primary: boolean; sort_order: number }[] | null;
            }
            
            return relatedCars.map((car: RelatedCarQueryResult): OptimizedCarListItem => {
                let primaryImage = null;
                try { primaryImage = car.images?.sort((a,b) => (a.sort_order ?? 0) - (b.sort_order ?? 0)).find((img) => img.is_primary) || car.images?.[0]; } catch(e) {console.error("ImgErrRel", e)}
                let price = null;
                try {
                    if(Array.isArray(car.pricing)) { price = car.pricing?.[0]?.base_price; }
                    else if (typeof car.pricing === 'object' && car.pricing !== null) { price = car.pricing?.base_price; }
                } catch(e) {console.error("PriceErrRel", e)}

                 return {
                    id: car.id,
                    slug: car.slug,
                    name: car.name,
                    category: car.category,
                    primary_image_url: primaryImage?.url,
                    price_per_day: price,
                    available: true, 
                    featured: null, 
                    hidden: false, 
                    created_at: null, 
                    shortDescription: null,
                };
            });
        } catch (error) {
            console.error("Error fetching related cars:", error);
            if (error instanceof Error) throw new Error(handleSupabaseError(error));
            throw new Error("An unexpected error occurred fetching related cars");
        }
     },

    // RE-ADD simple functions for Archive/Unarchive (toggle hidden flag)
    archiveCar: async (supabase: SupabaseClient, carId: string): Promise<boolean> => {
        try {
            const { error } = await supabase
                .from('cars')
                .update({ hidden: true, updated_at: new Date().toISOString() })
                .eq('id', carId);
            if (error) throw error;
            return true;
        } catch(error) {
            console.error(`Error archiving car ${carId}:`, error);
            if (error instanceof Error) throw new Error(handleSupabaseError(error));
            throw new Error("An unexpected error occurred archiving the car.");
        }
    },

    unarchiveCar: async (supabase: SupabaseClient, carId: string): Promise<boolean> => {
        try {
            const { error } = await supabase
                .from('cars')
                .update({ hidden: false, updated_at: new Date().toISOString() })
                .eq('id', carId);
             if (error) throw error;
             return true;
        } catch(error) {
            console.error(`Error unarchiving car ${carId}:`, error);
            if (error instanceof Error) throw new Error(handleSupabaseError(error));
            throw new Error("An unexpected error occurred unarchiving the car.");
        }
    }

}

// Helper function to generate slug (can be moved to utils)
function generateSlug(name: string): string {
    return name
        .toLowerCase()
        .replace(/\s+/g, '-')       // Replace spaces with -
        .replace(/[^\w-]+/g, '')    // Remove all non-word chars except -
        .replace(/--+/g, '-')       // Replace multiple - with single -
        .replace(/^-+/, '')          // Trim - from start of text
        .replace(/-+$/, '');         // Trim - from end of text
}

// Note: Assumed BUCKET_NAMES.VEHICLE_IMAGES exists and is correctly configured.
// Note: Assumed database types (`Database['public']['Tables']...`) are generated and accurate.
//       Run `npx supabase gen types typescript --project-id <your-project-id> --schema public > lib/types/database.types.ts` if needed.
// Note: Transactional integrity is NOT guaranteed by these separate calls. Use Supabase Edge Functions (RPC with pg_transaction) for atomic operations in production.

